#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass ociamthesis-lyx
\begin_preamble
%Packages
\usepackage{listings}
\end_preamble
\options a4paper,titlepage
\use_default_options false
\maintain_unincluded_children false
\language spanish
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing onehalf
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 0
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine natbib
\cite_engine_type numerical
\biblio_style plainnat
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle headings
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Chapter
Implementación
\begin_inset CommandInset label
LatexCommand label
name "chap:Implementacion"

\end_inset


\end_layout

\begin_layout Standard
El objetivo de este capítulo es mostrar como se ha logrado implementar todo
 lo que se ha comentado en el capítulo anterior de diseño.
 Para ello se entrará en la implementación final profundizando en los aspectos
 más importantes para el trabajo.
 La implementación está dividida en 3 secciones.
 La primera sección explica el soporte multijugador que 
\shape italic
Unity3D
\shape default
 ofrece ya será necesario para entender aspectos de la implementación realizada.
 En la segunda sección se describe la implementación de la arquitectura
 del videojuego por medio del soporte de 
\shape italic
Unity3D
\shape default
.
 Esta sección está dividida en dos, las estructura y arquitectura del juego,
 al igual que se comentó en el diseño.
 Y en la tercera sección se muestra implementación de los técnicas de predicción.
 
\end_layout

\begin_layout Section
Unity3D Networking
\end_layout

\begin_layout Standard

\shape italic
Unity3D
\shape default
 pone a la disposición de los desarrolladores de un complejo y potente sistema
 para la implementación de juegos en red denominado Unity3D Networking 
\begin_inset CommandInset citation
LatexCommand citep
key "Unity3DNetworking"

\end_inset

.
 Este sistema esta muy bien integrado en el entorno y permite una rápido
 desarrollo.
 
\shape italic
Unity3D
\shape default
 ha trabajado muy duro para que las comunicaciones sean tan robustas y flexibles
 como sea posible.
 Para entender mejor este sistema se van comentar las principales clases
 que conforman al sistema.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Subsection

\shape italic
Network
\end_layout

\begin_layout Standard
Se trata de la clase principal de la implementación de red proveyendo de
 las funciones y atributos del núcleo 
\begin_inset CommandInset citation
LatexCommand citep
key "Unity3DNetwork"

\end_inset

.
 Esta clase configura la interfaz de red y todos los parámetros de red.
 Se usa para configurar el servidor o para conectarse a uno previamente
 creado contando con una gran cantidad de funciones que ayudan a la gestión
 de tareas.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Mediante el uso de sus atributos permite conocer mucha información entre
 la cual está:
\end_layout

\begin_layout Itemize
Saber si el nodo es servidor o cliente
\end_layout

\begin_layout Itemize
Numero de conexiones, es decir el número de jugadores conectados.
\end_layout

\begin_layout Itemize
Frecuencia de envío de paquetes de actualización por parte de las entidades
\end_layout

\begin_layout Itemize
Obtener el tiempo actual de red.
\end_layout

\begin_layout Standard
Y gracias a las funciones que ofrece permite por ejemplo:
\end_layout

\begin_layout Itemize
Inicializar el servidor, pasando el número de conexiones máximas.
\end_layout

\begin_layout Itemize
Conectarse a un servidor y desconectarse
\end_layout

\begin_layout Itemize
Ejemplificar una entidad en red
\end_layout

\begin_layout Itemize
Obtener el 
\shape italic
ping
\shape default
 medio para un jugador
\end_layout

\begin_layout Standard
Además tiene una serie de mensajes para permitir capturar cuando sea conectado,
 desconectado del servidor, un jugador se ha conectado o desconectado, etc.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Subsection

\shape italic
NetworkView
\end_layout

\begin_layout Standard
La clase 
\shape italic
NetworkView
\shape default
 
\begin_inset CommandInset citation
LatexCommand citep
key "Unity3DNetworkView"

\end_inset

 o vista de red define que objetos deben estar sincronizados a través de
 la red así como se debe realizar esta sincronización.
 Esta clase se añade a un objeto y se le añade un 
\shape italic
script.

\shape default
 En Unity3D, un 
\shape italic
script 
\shape default
es un archivo que permite controlar y detallar relaciones entre los objetos
 creados a partir del editor entre otras funcionalidades.
 En este caso el 
\shape italic
script 
\shape default
agregado controla la información que se envían en los mensajes de actualización
 así que hacer cuando se reciben.
 También es posible pasarle directamente una trasformada del objeto (es
 decir la clase que contiene la posición, rotación y escala del objeto)
 y Unity lo hace automático.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Entre las propiedades que ofrece permite saber si la vista de red controla
 al objeto en sí, es decir si el objeto está en el nodo propietario.
 Esta propiedad es muy importante ya que según si se está en el nodo propietario
 o no las acciones que hay que hacer con respecto al objeto son muy diferentes.
 También destacar que permite hacer uso de RPC o 
\shape italic
Remote Procedure Call
\shape default

\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "RPC"
description "Remote Procedure Call\\\\"

\end_inset

 para llamar a funciones en todos los jugadores, algo muy cómodo y útil
 que ofrece una gran potencia, por ejemplo si un jugador recibe daño se
 llama a un método por RPC para que quite salud a ese jugador en todos los
 nodos.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Subsection

\shape italic
NetworkViewID
\end_layout

\begin_layout Standard
Esta clase sencillamente representa un identificador único para cada instancia
 de la clase 
\shape italic
NetworkView
\shape default
 en el juego multijugador 
\begin_inset CommandInset citation
LatexCommand citep
key "Unity3DNetworkViewID"

\end_inset

.
 Esta clase cumple un papel fundamental ya que es muy importante que el
 identificador sea único entre todos los clientes y que se puedan generar
 para que la sincronización de la red no se corrompa.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Subsection

\shape italic
NetworkMessageInfo
\end_layout

\begin_layout Standard
Se trata de una estructura de datos que contiene información sobre el mensaje
 que acaba de ser recibido desde la red 
\begin_inset CommandInset citation
LatexCommand citep
key "Unity3DNetworkMessageInfo"

\end_inset

.
 La información que contiene es la 
\shape italic
NetworkView
\shape default
 y jugador que envió el mensaje y la marca de tiempo el que se envió.
 Esta marca de tiempo en el que el paquete fue enviado tendrá un papel fundament
al para el capítulo siguiente.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Subsection

\shape italic
MasterServer
\end_layout

\begin_layout Standard
Esta clase se utiliza para que la búsqueda de partidas entre los servidores
 y los clientes se facilite enormemente 
\begin_inset CommandInset citation
LatexCommand citep
key "Unity3DMasterServer"

\end_inset

.
 Permite entre lo más destacable anunciar los hosts o realizar una petición
 de la lista de hosts para el juego en cuestión.
 
\end_layout

\begin_layout Subsection
Objetos de 
\shape italic
Unity3D Networking
\shape default
 usados en EoS
\end_layout

\begin_layout Standard
Todos objetos existentes en Unity3D Networking han sido utilizados en el
 desarrollo del videojuegos EoS.
 El único que ha tenido poca relevancia en el desarrollo ha sido 
\shape italic
NetworkViewID
\shape default
.
 
\end_layout

\begin_layout Section
Descripción videojuego 
\shape italic
End of Shooter
\end_layout

\begin_layout Standard
En las siguientes subsecciones se trataran diversos aspectos de la implementació
n de EoS: la estructura del videojuego, y su arquitectura de red.
\end_layout

\begin_layout Subsection
Estructura del videojuego
\begin_inset CommandInset label
LatexCommand label
name "sub:IMPEstructura-del-videojuego"

\end_inset


\end_layout

\begin_layout Standard
Como se ha comentado en el diseño el juego consta de dos escenas, el menú
 y la de juego.
 En este parte se desglosa cada una de las escenas para ver que elementos
 la componen, así como se implementan y que funciones cumplen.
 Principalmente se dedicará mayor atención a los elementos que tienen alguna
 implicación con el multijugador en sí ya que son los que más interesan
 para el objetivo del proyecto.
 
\end_layout

\begin_layout Subsubsection
Escena de menú
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
En cuanto a la jerarquía de la escena queda representa en la Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:MenuSceneHierarchy-1"

\end_inset

.
 En la escena solamente se añade un objeto el cual está vacío, es decir
 es invisible.
 Este objeto al que se denomina 
\shape italic
GameController
\shape default
 se le añade un 
\shape italic
script
\shape default
 el cuál incluye toda la lógica para crear el menú, 
\shape italic
MainMenu
\shape default
.
 Además debido a que se necesitan hacer llamadas RPC para indicar a los
 jugadores que mapa deben cargar cuando se unen al servidor se necesitar
 añadir un 
\shape italic
NetworkView
\shape default
.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../figures/MenuSceneHierarchy.png
	width 75text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Esquema de la escena de menú
\begin_inset CommandInset label
LatexCommand label
name "fig:MenuSceneHierarchy-1"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Además por incluir un poco de dinamismo se ha añadido una cámara para que
 se renderice un cielo y se la añadido un sencillo 
\shape italic
script
\shape default
 para que gire la cámara quedando un menú más atractivo.
 
\end_layout

\begin_layout Subsubsection
Escena de juego
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La escena de juego presenta más complejidad que el menú debido a la mayor
 cantidad de elementos que se requieren así como la funcionalidad de estos.
 Al igual que se ha hecho con la escena de menú, en la Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:GameSceneHierarchy"

\end_inset

 se muestra el esquema a partir del cuál se comentarán los diferentes elementos.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../figures/GameSceneHierarchy.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Esquema de la escena de menú
\begin_inset CommandInset label
LatexCommand label
name "fig:GameSceneHierarchy"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Scene: este objeto es el modelo del escenario.
\end_layout

\begin_layout Itemize
Rotate Around: este objeto se ha creado para que al iniciar la escena haya
 una cámara rotando alrededor del escenario hasta que el jugador quiera
 comenzar.
 El objeto que gira está constituido por una cámara y un 
\shape italic
script
\shape default
 que modifica su rotación con el paso del tiempo.
 
\end_layout

\begin_layout Itemize
Spawns: este objeto representa el conjunto de posiciones donde los jugadores
 reaparecen al iniciar o después de ser eliminados.
 
\end_layout

\begin_layout Itemize
GameController: se encarga de mostrar un simple menú al inicio para que
 que el jugador pueda comenzar la partida y además maneja la desconexión
 del jugador o servidor para que se vuelva a la escena del menú.
 
\end_layout

\begin_layout Itemize
Player: este objeto representa a cada jugador en la partida.
 El jugador se trata de la entidad más compleja de todo el juego debido
 a todo lo que tiene que hacer: sincronización, animaciones, ajustes, HUD,
 minimapa, etc.
 A continuación se ve con mucho más detalle este elemento entrando en las
 diferentes partes que lo componen ya que es el más importante y complejo.
 
\end_layout

\begin_layout Paragraph
Clase jugador 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
El jugador es la entidad más compleja de todo el juego.
 Esto es debido a por que esta formado por múltiples elementos como es el
 modelado compuesto por cientos de partes, las animaciones del modelo (andar,
 correr, desplazarse, apuntar ...
 ), múltiples 
\shape italic
scripts
\shape default
 con objetivos diferentes como el control mediante el ratón y teclado, el
 movimiento, el HUD, los sonidos para las diferentes acciones que el jugador
 puede realizar, etc.
 En la Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:PlayerHierarchy"

\end_inset

 se pueden ver prácticamente todos los elementos que componen al jugador
 ya que algunos se han obviado por simplificar.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Un aspecto fundamental es que si vemos hay algunos elementos que se repiten,
 es decir tienen el mismo nombre, esto es debido a como se implementa al
 jugador en primera persona.
 Si se observa la figura hay un elemento que se denomina MainRoot y por
 otra parte otro que se denomina 
\shape italic
Model
\shape default
.
 El jugador se ha implementado de tal forma que esta compuesto por el 
\shape italic
Model 
\shape default
o modelo 3D del personaje del cuerpo entero y por otra parte se ha replicado
 las manos y la arma obteniendo lo que se ha denominado 
\shape italic
MainRoot
\shape default
.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Esto se ha implementado así debido a que cuando se maneja a un jugador lo
 único que nos importa del personaje que movemos es que se muestre el arma
 y las manos, y por tanto se desactiva el modelo del cuerpo completo (así
 como todas las funciones y elementos referido a él).
 Pero por el contrario a los demás jugadores en el dispositivo si se necesita
 que se muestre su modelo se muestre al completo y por el contrario se desactive
 el 
\shape italic
MainRoot
\shape default
 ya que estos jugadores no están controlados por el jugador local sino remotamen
te por otros jugadores.
 En los dispositivos de los demás jugadores pasará justamente lo contrario.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Respecto a los elementos de red que el jugador contiene son los 
\shape italic
NetworkView
\shape default
 así como sus 
\shape italic
scripts
\shape default
 asociados.
 Los más importantes son los 
\shape italic
scripts
\shape default
 denominados 
\shape italic
NetworkRigidBody
\shape default
 los cuales se encargan de enviar las actualizaciones así como recibirlas
 para procesarlas aplicando las técnicas comentadas adecuadamente.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename ../figures/PlayerHierarchy.png
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Esquema de los elementos que componen al jugador
\begin_inset CommandInset label
LatexCommand label
name "fig:PlayerHierarchy"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Arquitectura de red
\end_layout

\begin_layout Subsubsection
Servidor 
\end_layout

\begin_layout Standard
Los servidores se han optado por que sean los propios clientes.
 Es decir un cliente será el host de la partida, es decir actuará como cliente
 y servidor.
 De este modo no es necesario un proyecto solamente para el servidor además
 de poder eliminar las máquinas que actuarían como servidores.
 Como desventaja, la implementación de los clientes aumenta en complejidad
 ya que se tiene que implementar el servidor y gestionar todo lo relacionado
 con él.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
En cuanto a el juego la implementación del servidor es relativamente sencilla.
 En el menú del juego se permite al jugador iniciar el servidor, es decir
 crear una partida a la que otros jugadores se podrán unir.
 Cuando se pulsa este botón se ejecuta el código que se muestra en el Alg.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:CreaciondelServidor"

\end_inset

.
 En el código primeramente se inicializa la capa de seguridad.
 El objetivo de esta capa es, si se implementa, es evitar mediante diferentes
 procedimientos como encriptación que los jugadores hagan trampas o trucos.
 A continuación se inicializa el servidor indicándole el número máximo de
 conexiones (que no tiene que coincidir con el de jugadores), el puerto
 en el que escuchará y si se usa 
\shape italic
Network Address Translation
\shape default
 o NAT 
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "NAT"
description "Network Address Translation\\\\\\\\"

\end_inset

.
 Por último se registra que hay un cliente que ha creado un servidor indicando
 el identificador del juego, el nombre del servidor (el nombre que el jugador
 quiera) y un comentario sin utilidad aparente.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=[Sharp]C,breaklines=true,basicstyle=
\backslash
footnotesize} 
\backslash
begin{lstlisting}[frame=single] 
\end_layout

\begin_layout Plain Layout

if (GUILayout.Button ("Start Server")) {
\end_layout

\begin_layout Plain Layout

	Network.InitializeSecurity (); 		
\end_layout

\begin_layout Plain Layout

	Network.InitializeServer(maxConnections,port,true); 	
\end_layout

\begin_layout Plain Layout

	MasterServer.RegisterHost(uniqueGameName,gameName,"Comment: TFG");
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Creación del Servidor
\begin_inset CommandInset label
LatexCommand label
name "alg:CreaciondelServidor"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Con estas simples sentencias el servidor está listo exceptuando algunos
 detalles sin importancia.
 Queda implementar como los clientes descubren que existe un nuevo servidor
 al que unirse.
 
\end_layout

\begin_layout Subsubsection
Cliente 
\end_layout

\begin_layout Standard
Para que un cliente se una a una partida y no sea él quién cree la partida
 es necesario primero conocer que servidores están disponibles.
 En Alg.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:ObtenerListaHost"

\end_inset

 se tiene la implementación para obtener la lista de servidores.
 Primeramente al iniciar el menú se invoca a un método que llama periódicamente
 a una función.
 Esta función lo que hace es sencillamente usar la clase
\shape italic
 MasterServer
\shape default
 para que realice una petición de la lista de host disponibles para el identific
ador del juego.
 Por último en el método Update el cuál se ejecuta en cada fotograma se
 obtiene haciendo otra vez uso de 
\shape italic
MasterServer 
\shape default
la lista de host más actual que se tiene.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=[Sharp]C,breaklines=true,basicstyle=
\backslash
footnotesize} 
\backslash
begin{lstlisting}[frame=single] 
\end_layout

\begin_layout Plain Layout

void Start()     {
\end_layout

\begin_layout Plain Layout

    InvokeRepeating("GetHostList", 0, refreshTime);   
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

void GetHostList() {         
\end_layout

\begin_layout Plain Layout

	MasterServer.RequestHostList(uniqueGameName);    
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

void Update()     
\end_layout

\begin_layout Plain Layout

{                  
\end_layout

\begin_layout Plain Layout

	datas = MasterServer.PollHostList();     
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Obtener lista de host
\begin_inset CommandInset label
LatexCommand label
name "alg:ObtenerListaHost"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Una vez ya disponemos de la lista de host solamente hay que mostrarla al
 jugador el cual decidiría a que partida quiere unirse.
 La clase que representa a un host se denomina 
\shape italic
HostData
\shape default
, y permite acceder a su nombre, jugadores conectados y su límite por lo
 que se le puede mostrar al usuario esta información.
 Cuando el jugador elige un host al que conectarse se llama el método 
\shape italic
Connect
\shape default
 de la clase 
\shape italic
Network
\shape default
 pasándole el host seleccionado como aparece en el Alg.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:ConectarHost"

\end_inset

.
 En el código se muestra también como se ha usado un scroll para representar
 a los hosts.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=[Sharp]C,breaklines=true,basicstyle=
\backslash
footnotesize} 
\backslash
begin{lstlisting}[frame=single] 
\end_layout

\begin_layout Plain Layout

GUI.Box (new Rect (Screen.width - 400 * dif, 0, 400 * dif, Screen.height),
 "");
\end_layout

\begin_layout Plain Layout

GUILayout.BeginArea (new Rect (Screen.width - 400 * dif, 0, 400 * dif, Screen.heigh
t)); 
\end_layout

\begin_layout Plain Layout

GUILayout.Label ("Avaiable Servers: " + datas.Length); 			
\end_layout

\begin_layout Plain Layout

scroll = GUILayout.BeginScrollView (scroll); 
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

foreach(HostData data in datas) {
\end_layout

\begin_layout Plain Layout

	GUILayout.BeginHorizontal (); 				
\end_layout

\begin_layout Plain Layout

	GUILayout.Label(data.gameName+" Players: " + data.connectedPlayers + "/" +
 data.playerLimit);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (GUILayout.Button ("Connect")) {
\end_layout

\begin_layout Plain Layout

		Network.Connect (data);   					
\end_layout

\begin_layout Plain Layout

 	   curMenu = 6;
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

	GUILayout.EndHorizontal ();
\end_layout

\begin_layout Plain Layout

} 	
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

GUILayout.EndScrollView (); 			
\end_layout

\begin_layout Plain Layout

GUILayout.EndArea ();
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Conectarse a un host
\begin_inset CommandInset label
LatexCommand label
name "alg:ConectarHost"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por último comentar que haciendo uso de RPC se consigue que los jugadores
 cuando se conecten carguen el mismo mapa que el host escogió.
 En el Alg.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:CargarNivelRPC"

\end_inset

 se muestra el método OnServerInitialized el cual se llama cuando el servidor
 se crea.
 Dentro del método se obtiene el 
\shape italic
NetworkView
\shape default
 asociado al objeto que contiene el 
\shape italic
script
\shape default
 y haciendo uso de RPC se llama a la función 
\shape italic
LoadLevel
\shape default
.
 El modo 
\shape italic
AllBufered
\shape default
 significa que la llamada a esta función se guarde en un buffer enviándose
 a todos los clientes que se conecten posteriormente.
 El último parámetro es un entero que indica el nivel a cargar y se pasa
 como parámetro de 
\shape italic
LoadLevel
\shape default
.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=[Sharp]C,breaklines=true,basicstyle=
\backslash
footnotesize} 
\backslash
begin{lstlisting}[frame=single] 
\end_layout

\begin_layout Plain Layout

void OnServerInitialized(){
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

	GetComponent<NetworkView>().RPC("LoadLevel",RPCMode.AllBuffered, maps[curMapIndex
].levelName); 		
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

[RPC]     
\end_layout

\begin_layout Plain Layout

void LoadLevel(string level){         
\end_layout

\begin_layout Plain Layout

         Application.LoadLevel(level); 		
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Cargar el nivel haciendo uso de RPC
\begin_inset CommandInset label
LatexCommand label
name "alg:CargarNivelRPC"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Técnicas de predicción de movimiento
\begin_inset CommandInset label
LatexCommand label
name "sec:IMPTécnicas-de-predicción"

\end_inset


\end_layout

\begin_layout Standard
En este apartado se va a desarrollar como sean implementado exactamente
 la sincronización para las entidades distribuidas, los personajes.
 Precisamente se va explicar el 
\shape italic
script
\shape default
 denominado 
\shape italic
NetworkRigidBody
\shape default
 que se ha comentado anteriormente referido al personaje.
 Para que sea más comprensible se dividirá el 
\shape italic
script
\shape default
 en 3 partes:
\end_layout

\begin_layout Itemize
Inicialización: en este parte se comentan las variables necesarias más important
e que permiten una mayor comodidad y simpleza en la implementación.
\end_layout

\begin_layout Itemize
Envío y recepción: se muestra como se envían la información de actualización
 así como lo que se realiza cuando se recibe.
 
\end_layout

\begin_layout Itemize
Procesamiento de las actualizaciones: se explica primeramente más rápido
 como se realiza la interpolación para posteriormente centrarse en la implementa
ción de diferentes técnicas predicción.
\end_layout

\begin_layout Subsection
Inicialización
\end_layout

\begin_layout Standard
Por comodidad se ha definido una estructura denominada 
\shape italic
State
\shape default
, Fig.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:EstructuraState"

\end_inset

, que representa a un estado que se va enviar o también recibir.
 Este estado está compuesto por una marca de tiempo, la posición, velocidades
 y aceleraciones necesarias para poder realizar las técnicas.
 Se ha decido enviar todas las necesarias independientemente del tipo de
 la técnica que se use ya que es mucho más cómodo para la evaluación.
 En un caso real se enviarán solamente las necesarias mejorando la eficiencia.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=[Sharp]C,breaklines=true,basicstyle=
\backslash
footnotesize} 
\backslash
begin{lstlisting}[frame=single] 
\end_layout

\begin_layout Plain Layout

internal struct  State{
\end_layout

\begin_layout Plain Layout

		internal double timestamp;    //indica el instante de tiempo					 
\end_layout

\begin_layout Plain Layout

		internal Vector3 pos; 	    //posición 		
\end_layout

\begin_layout Plain Layout

		internal Vector3 velocity;    //velocidad 		
\end_layout

\begin_layout Plain Layout

		internal Vector3 acceleration;//aceleración
\end_layout

\begin_layout Plain Layout

		internal Quaternion rot;      //rotación
\end_layout

\begin_layout Plain Layout

		internal Vector3 angularVelocity;//velocidad angular rad/s 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Estructura State
\begin_inset CommandInset label
LatexCommand label
name "alg:EstructuraState"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por otra parte se ha definido un buffer con un tamaño fijo de 20 en el cuál
 se van almacenando los paquetes recibidos más recientes según su orden.
 Esto quiere decir que no tiene por que estar ordenados según la marca de
 tiempo y por tanto después será necesario comprobar para aplicar las técnicas.
 El tamaño escogido puedes ser mayor o incluso menos, pero con 20 es más
 que suficiente para que siempre haya paquetes recientes aunque se desordenen
 o haya algunas pérdidas.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=[Sharp]C,breaklines=true,basicstyle=
\backslash
footnotesize} 
\backslash
begin{lstlisting}[frame=single] 
\end_layout

\begin_layout Plain Layout

// Se almacenan los 20 o X últimos actualizaciones de estado.
  	
\end_layout

\begin_layout Plain Layout

State[] m_BufferedState = new State[20];
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Creación del 
\shape italic
buffer
\shape default

\begin_inset CommandInset label
LatexCommand label
name "alg:Buffer"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Envío y recepción de mensajes de actualización
\end_layout

\begin_layout Standard
El método que se llama tanto para el envió como para la recepción se denomina
 
\shape italic
OnSerializeNetworkView
\shape default
.
 Este método tiene dos parámetros, el primero de ellos es el stream para
 en envío y el otro es información adicional.
 Gracias al stream se puede comprobar mediante un atributo que tiene si
 esta escribiendo o por el contrario está recibiendo.
 De este modo se obtiene la diferencia entre los dos casos.
 En el Alg.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:OnSerializeNetworkView"

\end_inset

 se ve la función al completo la cual se comentará cada una de las partes.
 
\begin_inset Newline newline
\end_inset


\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=[Sharp]C,breaklines=true,basicstyle=
\backslash
footnotesize} 
\backslash
begin{lstlisting}[frame=single] 
\end_layout

\begin_layout Plain Layout

void OnSerializeNetworkView(BitStream stream, NetworkMessageInfo info) {
 	
\end_layout

\begin_layout Plain Layout

	// Se envian datos al servidor!!
\end_layout

\begin_layout Plain Layout

	if (stream.isWriting){
\end_layout

\begin_layout Plain Layout

		Vector3 pos = transform.position;
\end_layout

\begin_layout Plain Layout

		Vector3 velocity = rigidBody.velocity;
\end_layout

\begin_layout Plain Layout

		Vector3 acceleration = (rigidBody.velocity - lastVelToSend) / Time.fixedDeltaTim
e;
\end_layout

\begin_layout Plain Layout

		lastVelToSend = rigidBody.velocity;
\end_layout

\begin_layout Plain Layout

		Quaternion rot = transform.rotation;
\end_layout

\begin_layout Plain Layout

		Vector3 angularVelocity = rigidBody.angularVelocity;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		stream.Serialize(ref pos);
\end_layout

\begin_layout Plain Layout

		stream.Serialize(ref velocity);
\end_layout

\begin_layout Plain Layout

		stream.Serialize(ref acceleration);
\end_layout

\begin_layout Plain Layout

		stream.Serialize(ref rot); 			
\end_layout

\begin_layout Plain Layout

		stream.Serialize(ref angularVelocity);
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

	// Read data from remote client
\end_layout

\begin_layout Plain Layout

	else{
\end_layout

\begin_layout Plain Layout

		Vector3 pos = Vector3.zero;
\end_layout

\begin_layout Plain Layout

		Vector3 velocity = Vector3.zero;
\end_layout

\begin_layout Plain Layout

		Vector3 acceleration = Vector3.zero;
\end_layout

\begin_layout Plain Layout

		Quaternion rot = Quaternion.identity;
\end_layout

\begin_layout Plain Layout

		Vector3 angularVelocity = Vector3.zero;
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		stream.Serialize(ref pos);
\end_layout

\begin_layout Plain Layout

		stream.Serialize(ref velocity);
\end_layout

\begin_layout Plain Layout

		stream.Serialize(ref acceleration);
\end_layout

\begin_layout Plain Layout

		stream.Serialize(ref rot);
\end_layout

\begin_layout Plain Layout

		stream.Serialize(ref angularVelocity);
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		// Shift the buffer sideways, deleting state 20
\end_layout

\begin_layout Plain Layout

		for (int i=m_BufferedState.Length-1;i>=1;i--){
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

			m_BufferedState[i] = m_BufferedState[i-1];
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

		// Actual estado recibido!!
\end_layout

\begin_layout Plain Layout

		State state; 			
\end_layout

\begin_layout Plain Layout

		state.timestamp = info.timestamp;
\end_layout

\begin_layout Plain Layout

		state.pos = pos;
\end_layout

\begin_layout Plain Layout

		state.velocity = velocity;
\end_layout

\begin_layout Plain Layout

		state.acceleration = acceleration;
\end_layout

\begin_layout Plain Layout

		state.rot = rot;
\end_layout

\begin_layout Plain Layout

		state.angularVelocity = angularVelocity;
\end_layout

\begin_layout Plain Layout

		m_BufferedState[0] = state; 
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementación del envío y recepción en el método 
\shape italic
OnSerializeNetworkView
\shape default

\begin_inset CommandInset label
LatexCommand label
name "alg:OnSerializeNetworkView"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Envío de mensajes
\end_layout

\begin_layout Standard
Mediante la propiedad 
\shape italic
isWriting
\shape default
 se comprueba que se va a enviar una actualización.
 Por tanto lo que se hace es obtener todos los parámetros que se quieren
 enviar y se serializan.
 Esta sección del código solamente se ejecutará para elementos propietarios,
 es decir, para los jugadores locales, es decir en cada dispositivo solamente
 habrá uno que sea local y envíe su información de actualización al servidor,
 el cual reenviará al resto.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Subsubsection
Recepción de mensajes
\end_layout

\begin_layout Standard
En caso de que no este escribiendo, no queda otra que recibir.
 En este caso se crean variables para pasarlas por referencia y recibir
 los datos de la actualización que se acaba de recibir.
 Una vez se recibe la información con ella se crea un estructura de tipo
 State para almacenar la información y por último insertarla en el buffer
 en la primera posición ya que es la más reciente.
 
\end_layout

\begin_layout Subsection
Procesamiento de las actualizaciones 
\begin_inset CommandInset label
LatexCommand label
name "sub:IMPProcesamientoActualizaciones"

\end_inset


\end_layout

\begin_layout Standard
El juego ejecuta el método 
\shape italic
Update
\shape default
 en cada 
\shape italic
script
\shape default
 por cada nuevo fotograma.
 En esta función se añade el código para implementar tanto la lógica de
 las entidades cómo en este caso las técnicas de predicción para las entidades
 distribuidas, es decir para los personajes.
 Las técnicas solamente serán aplicadas a los objetos o personajes que no
 sean propietarios, es decir a aquellos que no están siendo controlados
 por un usuario.
 Esto es debido a que el movimiento del personaje que controla el usuario
 está determinado por las entradas que este produzca.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
En el Alg.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:MétodoUpdate"

\end_inset

 se ve el método 
\shape italic
Update
\shape default
 en el cual mediante la propiedad 
\shape italic
isMine
\shape default
 que ofrece la 
\shape italic
NetworkView
\shape default
 asociada al 
\shape italic
script
\shape default
 se puede diferenciar si el objeto es propietario, es decir en este caso
 es el personaje manejado por el usuario o si por el contrario no lo es
 siendo un personaje controlado por un usuario remoto.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=[Sharp]C,breaklines=true,basicstyle=
\backslash
footnotesize} 
\backslash
begin{lstlisting}[frame=single] 
\end_layout

\begin_layout Plain Layout

void Update () {
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (!nView.isMine) {
\end_layout

\begin_layout Plain Layout

		//No se es propietario de la NetworkView,
\end_layout

\begin_layout Plain Layout

		//por lo tanto es controlada remotamente.
\end_layout

\begin_layout Plain Layout

		//Será necesario aplicar las técnicas.
 
\end_layout

\begin_layout Plain Layout

	}else{  
\end_layout

\begin_layout Plain Layout

		//Propietario de la NetworkView, 
\end_layout

\begin_layout Plain Layout

		//y por lo tanto también de la instancia, del personaje.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Método 
\shape italic
Update
\shape default

\begin_inset CommandInset label
LatexCommand label
name "alg:MétodoUpdate"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Por lo que solamente se aplicarán las técnicas en la primera condición dejando
 la otra posibilidad vacía.
 Una vez ya se tiene claro está diferenciación es necesario crear otra para
 ver cuando se aplica una técnica u otra según el diseño que se realizó.
 Para poder hacer está diferenciación se necesita tomar un tiempo máximo
 de interpolación.
 Este tiempo depende de la tasa al que se envían las actualizaciones de
 estado.
 En la implementación se obtiene el tiempo de red y se le resta el tiempo
 máximo de interpolación obteniendo lo que sea ha denominado tiempo de interpola
ción o el tiempo renderizado.
 Una vez se tiene este tiempo se compara con la marca de tiempo del último
 paquete recibido.
 En caso de que la marca de este paquete sea mayor se realiza la interpolación
 y en caso contrario se aplican técnicas de predicción.
 En el Alg.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:interpolacion"

\end_inset

 se puede observar como se diferencian ambas técnicas según se ha explicado.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Para la interpolación lo que se realiza es buscar los dos paquetes con la
 marca de tiempo más actual.
 Una vez se encuentran se calcula cuanto tiempo es necesario interpolar
 mediante la diferencia de sus marcas de tiempo y por último se utiliza
 una función que ofrece Unity3D denominada 
\shape italic
Lerp
\shape default
 que realiza una interpolación lineal entre dos posiciones dependiendo de
 una variable que se le pasa que indica de que posición estará más cerca
 la interpolación.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=[Sharp]C,breaklines=true,basicstyle=
\backslash
footnotesize} 
\backslash
begin{lstlisting}[frame=single] 
\end_layout

\begin_layout Plain Layout

// Este es el tiempo quitandole actual de renderizado, o el tiempo limite
 de interpolación.
 			
\end_layout

\begin_layout Plain Layout

double interpolationTime = Network.time - m_IntLimit;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Usamos interpolación si el tiempo objetivo está en el buffer.
 Esto
\end_layout

\begin_layout Plain Layout

// no sucederá si no se mantiene el rate de llegada de actualizaciones 
\end_layout

\begin_layout Plain Layout

// de estados.
 Esto se puede deber a diversos problemas.
  
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

if (m_BufferedState [0].timestamp > interpolationTime) { 				
\end_layout

\begin_layout Plain Layout

	// Se recorre el buffer para encontrar el correcto.
 				
\end_layout

\begin_layout Plain Layout

	// Una vez se encuentra uno de ellos se sale del bucle.
 				
\end_layout

\begin_layout Plain Layout

	for (int i=0; i<m_TimestampCount; i++) { 					
\end_layout

\begin_layout Plain Layout

		if (m_BufferedState [i].timestamp <= interpolationTime || i == m_TimestampCount
 - 1) {
\end_layout

\begin_layout Plain Layout

			// Es el mejor estado, el más actual.
 Normalmente será el 0.
 						
\end_layout

\begin_layout Plain Layout

			// Está fijado como máximo a una antiguedad menor o igual que m_IntLimit.
\end_layout

\begin_layout Plain Layout

			State rhs = m_BufferedState [Mathf.Max (i - 1, 0)]; 						
\end_layout

\begin_layout Plain Layout

			// El más cercano al más actual.
 Más antiguo que "rhs".
\end_layout

\begin_layout Plain Layout

			State lhs = m_BufferedState [i];
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

			// Se calcula el tiempo entre los dos estados para saber 						
\end_layout

\begin_layout Plain Layout

			// si la interpolación es necesaria.
\end_layout

\begin_layout Plain Layout

			double length = rhs.timestamp - lhs.timestamp;
\end_layout

\begin_layout Plain Layout

			float t = 0.0F;
\end_layout

\begin_layout Plain Layout

			if (length > 0.0001) {
\end_layout

\begin_layout Plain Layout

				t = (float)((interpolationTime - lhs.timestamp) / length);
\end_layout

\begin_layout Plain Layout

			} 						
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

			// Si t=0 => lhs se utiliza directamente
\end_layout

\begin_layout Plain Layout

			transform.position = Vector3.Lerp (lhs.pos, rhs.pos, t);
\end_layout

\begin_layout Plain Layout

			transform.rotation = Quaternion.Slerp (lhs.rot, rhs.rot, t);
\end_layout

\begin_layout Plain Layout

			return;
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

// Se usa extrapolación en caso de que las actualizaciones no lleguen adecuadame
nte.
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

	//PREDICCIÓN
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementación de la Interpolación
\begin_inset CommandInset label
LatexCommand label
name "alg:interpolacion"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Para el caso de la predicción se establece un tiempo máximo entre el último
 paquete recibido y el tiempo de renderizado a partir del cual no se predice.
 En caso de que la marca del último paquete este dentro de este tiempo se
 aplica la técnica de predicción implementada.
 En el Alg.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "alg:interpolacion"

\end_inset

 se puede observar como con una variable se diferencia entre 4 tipos de
 técnicas, las cuales se explicaron teóricamente en el Cap.
 
\begin_inset CommandInset ref
LatexCommand ref
reference "chap:Estado-del-Arte"

\end_inset

.
 Para un juego que vaya a salir al mercado en esta parte se aplicaría solamente
 una técnica de predicción pero debido a comodidad para la evaluación es
 mucho más cómodo para cambiar entre las diferentes técnicas.
 Además cada técnica esta como una función independiente.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=[Sharp]C,breaklines=true,basicstyle=
\backslash
footnotesize} 
\backslash
begin{lstlisting}[frame=single] 
\end_layout

\begin_layout Plain Layout

// Este es el tiempo quitandole actual de renderizado, o el tiempo limite
 de interpolación.
 			
\end_layout

\begin_layout Plain Layout

double interpolationTime = Network.time - m_IntLimit;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Usamos interpolación si el tiempo objetivo está en el buffer.
 Esto
\end_layout

\begin_layout Plain Layout

// no sucederá si no se mantiene el rate de llegada de actualizaciones 
\end_layout

\begin_layout Plain Layout

// de estados.
 Esto se puede deber a diversos problemas.
  
\end_layout

\begin_layout Plain Layout

			
\end_layout

\begin_layout Plain Layout

if (m_BufferedState [0].timestamp > interpolationTime) { 				
\end_layout

\begin_layout Plain Layout

	//INTERPOLACIÓN
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

// Se usa extrapolación en caso de que las actualizaciones no lleguen adecuadame
nte.
\end_layout

\begin_layout Plain Layout

else {
\end_layout

\begin_layout Plain Layout

	State latest = m_BufferedState [0]; 		
\end_layout

\begin_layout Plain Layout

	float extrapolationLength = (float)(interpolationTime - latest.timestamp);
\end_layout

\begin_layout Plain Layout

	// No se hace extrapolación para más de ExtLimit, 500ms por defecto
\end_layout

\begin_layout Plain Layout

	if (extrapolationLength < m_ExtLimit) {
\end_layout

\begin_layout Plain Layout

		if (algorithm == 0) {
\end_layout

\begin_layout Plain Layout

			ExtOneStepFirstOrder (extrapolationLength);
\end_layout

\begin_layout Plain Layout

		} else if (algorithm == 1) {
\end_layout

\begin_layout Plain Layout

			ExtOneStepSecondOrder (extrapolationLength);
\end_layout

\begin_layout Plain Layout

		} else if (algorithm == 2) {
\end_layout

\begin_layout Plain Layout

			ExtTwoStepFirstOrder (extrapolationLength);
\end_layout

\begin_layout Plain Layout

		} else if (algorithm == 3) {
\end_layout

\begin_layout Plain Layout

			ExtTwoStepSecondOrder (extrapolationLength);
\end_layout

\begin_layout Plain Layout

		}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Implementación de la Predicción
\begin_inset CommandInset label
LatexCommand label
name "alg:extrapolacion"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Técnicas de predicción
\begin_inset CommandInset label
LatexCommand label
name "par:IMPTécnicas-de-Predicción"

\end_inset


\end_layout

\begin_layout Standard
Se ham implementado 4 técnicas de predicción: 
\end_layout

\begin_layout Itemize
Predicción en un paso de primer orden o OSFO (
\shape italic
One Step First Order
\shape default
)
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "OSFO "
description "One Step First Order"

\end_inset

.
\end_layout

\begin_layout Itemize
Predicción en dos pasos de primer orden o TSFO (
\shape italic
Two Step First Order
\shape default
)
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "TSFO"
description "Two Step First Order"

\end_inset

.
\end_layout

\begin_layout Itemize
Predicción en un pasos de segundo orden o OSSO (
\shape italic
One Step Second Order
\shape default
)
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "OSSO"
description "One Step Second Order"

\end_inset

.
\end_layout

\begin_layout Itemize
Predicción en dos pasos de segundo orden o TSSO (
\shape italic
Two Step Second Order
\shape default
)
\begin_inset CommandInset nomenclature
LatexCommand nomenclature
symbol "TSSO"
description "Two Step Second Order"

\end_inset

.
\end_layout

\begin_layout Paragraph
Predicción en un paso de primer orden
\begin_inset CommandInset label
LatexCommand label
name "par:OSFO"

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
La primera técnica de predicción es una extrapolación en un paso de primer
 orden.
 Para llevarla a cabo se obtiene la muestra más reciente y utilizando la
 información que esta contiene se aplica la fórmula de un movimiento uniforme.
 Es decir solamente se utiliza la posición y su primera derivada, la velocidad.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=[Sharp]C,breaklines=true,basicstyle=
\backslash
footnotesize} 
\backslash
begin{lstlisting}[frame=single] 
\end_layout

\begin_layout Plain Layout

private void ExtOneStepFirstOrder(float time){
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		State latest = m_BufferedState[0];
\end_layout

\begin_layout Plain Layout

		float angle = time * latest.angularVelocity.magnitude * Mathf.Rad2Deg;
\end_layout

\begin_layout Plain Layout

		Quaternion angularRotation = Quaternion.AngleAxis(angle, latest.angularVelocity)
; 	
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		transform.position = latest.pos + latest.velocity * time;
\end_layout

\begin_layout Plain Layout

		rigidBody.velocity = latest.velocity;
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		transform.rotation = angularRotation * latest.rot;
\end_layout

\begin_layout Plain Layout

		rigidBody.angularVelocity = latest.angularVelocity;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Función para la predicción en un paso de primer orden
\begin_inset CommandInset label
LatexCommand label
name "alg:OSFO"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Predicción en un paso de segundo orden
\begin_inset CommandInset label
LatexCommand label
name "par:OSSO"

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Si se le añade un orden, se hace uso de la segunda derivada de la posición
 tomando la fórmula de un movimiento uniformemente acelerado.
 En este caso si se hace uso de la posición junto con sus dos primeras derivadas
, la velocidad y la aceleración.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=[Sharp]C,breaklines=true,basicstyle=
\backslash
footnotesize} 
\backslash
begin{lstlisting}[frame=single] 
\end_layout

\begin_layout Plain Layout

private void ExtOneStepSecondOrder(float time){
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		State latest = m_BufferedState[0]; 	
\end_layout

\begin_layout Plain Layout

		float angle = time * latest.angularVelocity.magnitude * Mathf.Rad2Deg;
\end_layout

\begin_layout Plain Layout

		Quaternion angularRotation = Quaternion.AngleAxis(angle, latest.angularVelocity)
;	
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		transform.position = latest.pos + latest.velocity * time + 0.5f * latest.accelerati
on * Mathf.Pow(time,2);
\end_layout

\begin_layout Plain Layout

		rigidBody.velocity = latest.velocity;
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		transform.rotation = angularRotation * latest.rot;
\end_layout

\begin_layout Plain Layout

		rigidBody.angularVelocity = latest.angularVelocity; 	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Función para la predicción en un paso de segundo orden
\begin_inset CommandInset label
LatexCommand label
name "alg:OSSO"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Predicción en dos pasos de primer orden
\begin_inset CommandInset label
LatexCommand label
name "par:TSFO"

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
En caso de realizar la predicción en dos pasos es necesario obtener los
 dos estados más recientes.
 A partir de estos dos estados se calcula la primera derivada.
 Mediante las posiciones se obtiene primeramente la dirección de movimiento,
 la distancia entre ellas y la diferencia entre las marcas de tiempo.
 Una vez se tiene esta información se puede obtener la primera derivada
 de la posición, la velocidad como la distancia recorrida entre el tiempo.
 Obtenida la primera derivada aplica la fórmula de un movimiento uniforme.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=[Sharp]C,breaklines=true,basicstyle=
\backslash
footnotesize} 
\backslash
begin{lstlisting}[frame=single] 
\end_layout

\begin_layout Plain Layout

private void ExtTwoStepFirstOrder(float time){
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	State latest = m_BufferedState[0];
\end_layout

\begin_layout Plain Layout

	State nextToLast = m_BufferedState[1];
\end_layout

\begin_layout Plain Layout

	Vector3 directionV = latest.pos - nextToLast.pos; // Dirección del movimiento
\end_layout

\begin_layout Plain Layout

	float distance = Vector3.Distance (latest.pos, nextToLast.pos);
\end_layout

\begin_layout Plain Layout

	float timeDif = Convert.ToSingle (latest.timestamp - nextToLast.timestamp);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	if (Mathf.Approximately(distance, 0) || Mathf.Approximately(timeDif, 0))
 {
\end_layout

\begin_layout Plain Layout

		//No calculamos sino que directamente aplicamos la última ya que no hay
 diferencia entre ellas.
 
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		transform.position = latest.pos;
\end_layout

\begin_layout Plain Layout

		rigidBody.velocity = latest.velocity;
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		transform.rotation = latest.rot;
\end_layout

\begin_layout Plain Layout

		rigidBody.angularVelocity = latest.angularVelocity;
\end_layout

\begin_layout Plain Layout

		return;
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	float velocity = distance / timeDif; 	
\end_layout

\begin_layout Plain Layout

	directionV = directionV.normalized;
\end_layout

\begin_layout Plain Layout

	Vector3 expectedPosition = latest.pos + directionV * time * velocity;
\end_layout

\begin_layout Plain Layout

	transform.position = Vector3.Lerp(transform.position, expectedPosition, Time.deltaT
ime*velocity);
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Para el resto que no es la posicion, directamente la última.
\end_layout

\begin_layout Plain Layout

	float angle = time * latest.angularVelocity.magnitude * Mathf.Rad2Deg;
\end_layout

\begin_layout Plain Layout

	Quaternion angularRotation = Quaternion.AngleAxis(angle, latest.angularVelocity);
\end_layout

\begin_layout Plain Layout

	rigidBody.velocity = latest.velocity;
\end_layout

\begin_layout Plain Layout

	transform.rotation = angularRotation * latest.rot;
\end_layout

\begin_layout Plain Layout

	rigidBody.angularVelocity = latest.angularVelocity; 	
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Función para la predicción en dos paso de primer orden
\begin_inset CommandInset label
LatexCommand label
name "alg:TSFO"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Predicción en dos paso de segundo orden
\begin_inset CommandInset label
LatexCommand label
name "par:TSSO"

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
En este caso, a diferencia del anterior, se usan los dos estados más actuales
 para obtener la segunda derivada de la posición, la aceleración.
 Solamente es necesario obtener la aceleración ya que la velocidad se toma
 del estado más reciente.
 Para obtener la aceleración se calcula la dirección que está tiene, la
 diferencia de velocidad y el tiempo en el que se ha producido esa variación
 de velocidad.
 Con esta información se calcula la aceleración simplemente dividiendo la
 diferencia entre el tiempo.
 Por último se aplica la fórmula de un movimiento uniformemente acelerado.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
lstset{language=[Sharp]C,breaklines=true,basicstyle=
\backslash
footnotesize} 
\backslash
begin{lstlisting}[frame=single] 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

private void ExtTwoStepSecondOrder(float time){
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	State latest = m_BufferedState[0];
\end_layout

\begin_layout Plain Layout

	State nextToLast = m_BufferedState[1]; 	
\end_layout

\begin_layout Plain Layout

	Vector3 directionA = latest.velocity - nextToLast.velocity; // Dirección
 del movimiento
\end_layout

\begin_layout Plain Layout

	float distance = Vector3.Distance (latest.velocity, nextToLast.velocity);
\end_layout

\begin_layout Plain Layout

	float timeDif = Convert.ToSingle (latest.timestamp - nextToLast.timestamp);
 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	if (Mathf.Approximately(distance, 0) || Mathf.Approximately(timeDif, 0))
 {
\end_layout

\begin_layout Plain Layout

		//No calculamos sino que directamente aplicamos la última ya que no hay
 diferencia entre ellas.
  		
\end_layout

\begin_layout Plain Layout

		
\end_layout

\begin_layout Plain Layout

		transform.position = latest.pos;
\end_layout

\begin_layout Plain Layout

		rigidBody.velocity = latest.velocity;
\end_layout

\begin_layout Plain Layout

		transform.rotation = latest.rot;
\end_layout

\begin_layout Plain Layout

		rigidBody.angularVelocity = latest.angularVelocity;
\end_layout

\begin_layout Plain Layout

		return; 
\end_layout

\begin_layout Plain Layout

	} 	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	float acceleration = distance / timeDif; 	
\end_layout

\begin_layout Plain Layout

	directionA = directionA.normalized;
\end_layout

\begin_layout Plain Layout

	Vector3 expectedPosition = latest.pos + latest.velocity * time + 0.5f * directionA
 * acceleration * Mathf.Pow(time,2);
\end_layout

\begin_layout Plain Layout

	transform.position = Vector3.Lerp(transform.position, expectedPosition, Time.deltaT
ime*acceleration); 	
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	//Para el resto que no es la posicion, directamente la última.
 	
\end_layout

\begin_layout Plain Layout

	float angle = time * latest.angularVelocity.magnitude * Mathf.Rad2Deg;
\end_layout

\begin_layout Plain Layout

	Quaternion angularRotation = Quaternion.AngleAxis(angle, latest.angularVelocity);
 	
\end_layout

\begin_layout Plain Layout

	rigidBody.velocity = latest.velocity;
\end_layout

\begin_layout Plain Layout

	transform.rotation = angularRotation * latest.rot;
\end_layout

\begin_layout Plain Layout

	rigidBody.angularVelocity = latest.angularVelocity	
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
end{lstlisting}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Función para la predicción en dos paso de primer orden
\begin_inset CommandInset label
LatexCommand label
name "alg:TSSO"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
